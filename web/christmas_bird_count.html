<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="christmas_bird_count.css"/>
<body>
  <div class="main">
    <div class="div-header">
      <div class="legend">  
        <p>Circle size represents the number of observations in a given year. Move the mouse over any row to see the counts.</p>
       <!--  <p>Circle size can scaled in two ways:</p>
        <div>
        <input type="radio" value="1" name="rad" checked>
        <div class="button-desc">
          The area of the largest circle represents the highest count for that species.
          This allows comparison between years for each species individually.
        </div>
        </div>
        <br><br>

        <div>
        <input type="radio" value="2" name="rad">
        <div class="button-desc">
          The area of the largest circle represents the highest count for any species. 
          This allows comparison between species. </div>
        </div>
        <br><br>
        <div>1h = 100 observations --------------- 1k = 1,000 observations --------------- CP = observed during count period</div> -->
      </div>
    </div>
    <div class="div-body"></div>
  </div>
</body>
<script src="d3.v3.min.js"></script>
<script>

var data_path = '../data/'; //dir_christmas_bird_count/

var margin_t = {top: 3, right: 210, bottom: 0, left: 10}, // table
  margin_a = {top: 37, right: 210, bottom: 0, left: 10}, // axis
  margin_h = {top: 0, right: 210, bottom: 0, left: 10}, // histogram
  width = 720 - margin_t.right - margin_t.left, // 1100
  height_t = 2600 - margin_t.top - margin_t.bottom,
  height_a = 40 - margin_a.top - margin_a.bottom,
  height_h = 100 - margin_h.top - margin_h.top,
  row_h = 20,
  circle_max_size = 5, //9;
  start_year = 1952,
  end_year = 2014,
  record_end = width + 50,
  species_start = width + 60;

var year_col_w;

var window_width = window.innerWidth;

var x = d3.scale.linear()
  .range([0, width]);

var formatYears = d3.format("0000");

var xAxis = d3.svg.axis()
  .scale(x)
  .orient("top")
  .tickFormat(formatYears);

var svg_hist = create_svg(".div-header", margin_h, width, height_h)
var svg_header = create_svg(".div-header", margin_a, width, height_a)
var svg = create_svg(".div-body", margin_t, width, height_t)

d3.json(data_path + "web_data_cp.json", function(data) {

  x.domain([start_year, end_year]);
  
  var xScale = d3.scale.linear()
    .domain([start_year, end_year])
    .range([0, width]);

  year_col_w = xScale(2001) - xScale(2000);

  svg_header.append("g")
    .attr("class", "x axis")
    .call(xAxis);

  var header = svg_header.append("g").attr("class", "header");

  header.append("text")
    .attr("text-anchor", "end")
    .attr("y", -15)
    .attr("x", record_end)
    .attr("class", "label")
    .text('Max');

  header.append("text")
    .attr("text-anchor", "end")
    .attr("y", 0)
    .attr("x", record_end) 
    .attr("class", "label")
    .text('Count');
  
  header.append("text")
    .attr("y", 0)
    .attr("x", species_start)
    .attr("class", "label")
    .text("Species");

  draw_rows(1);

  // d3.selectAll("input").on("change", 
  //   function() { 
  //     draw_rows(this.value); }
  //   )

  function mouseover_2(p) {
    var year = d3.select(this).data()[0][0];
    var g = d3.select(this).node().parentNode;

    d3.select(g)
      .selectAll("circle")
      .filter(function(d) { return d[0] == year; })
      .attr("fill", "red")

    d3.select(g)
      .selectAll("text.value")
      .filter(function(d) { return d[0] == year; })
      .style("display", "block");
  }

  function mouseout_2(p) {
    var g = d3.select(this).node().parentNode;
    d3.select(g)
      .selectAll("circle")
      .attr("fill", function(d) {
        if (d[1] == d[2]) { return "green"; }
        return "grey";
      })
    d3.select(g).selectAll("text.value").style("display","none");
  }

  function draw_rows(value) {

    var rScale = d3.scale.pow().exponent(.5) // changed from .linear() which is wrong!!! the circle's area should map linearly to # of observations, not the radius!!!
      .range([0, circle_max_size]);
    svg.selectAll("g").remove();

    for (var j = 0; j < data.length; j++) {
      var g = svg.append("g").attr("class","species");

      if (value == 1) {
        rScale.domain([0, d3.max(data[j]['observations'], function(d) { return d[1]; })]);
      } else {
        rScale.domain([0, 3400]);
      }

      g.selectAll("circle")
        .data(data[j]['observations']) 
        .enter()
        .append("circle")
        .attr("cx", function(d) { return xScale(d[0]); })
        .attr("cy", (j+1)*row_h)
        .attr("r", function(d) { return rScale( (d[1]=='CP' ? 1 : d[1]) ); })
        .attr("fill", function(d) {
          if (d[1] == data[j]['max_count']) { return "green"; }
          return "grey";
        })

      g.selectAll("text")
        .data(data[j]['observations'])
        .enter()
        .append("text")
        .attr("text-anchor", "middle")
        .attr("y", (j+1)*row_h - circle_max_size - 1)//+ 5)
        .attr("x", function(d) { return xScale(d[0]); })
        .attr("class", "value")
        .text(function(d) { return val_formatter_2(d[1]); })
        .style("fill", "black")
        .style("display", "none");

      g.append("text")
        .attr("text-anchor", "end")
        .attr("y", (j+1)*row_h + 5)
        .attr("x", record_end)
        .attr("class", "column")
        .text(data[j]['max_count'])
        .style("fill", "green");

      g.append("text")
        .attr("y", (j+1)*row_h + 5)
        .attr("x", species_start)
        .attr("class", "label")
        .text(truncate(data[j]['name'], 30, "..."))
        .style("fill", "black");

      g.selectAll("rect")
        .data(data[j]['observations']) 
        .enter()
        .append("rect")
        .attr("x", function(d) { return xScale(d[0]) - year_col_w/2; })
        .attr("y", j*row_h+ row_h/2)
        .attr("width", year_col_w)
        .attr("height", row_h)
        .attr("opacity", 0)
        .on("mouseover", mouseover_2)
        .on("mouseout", mouseout_2)
    }
  };
});

function val_formatter_2(val) {
  if (val == 0) { return ''; }
  else { return val; }
}

function create_svg(id, margin, w, h) {
  return d3.select(id).append("svg")
           .attr("width", w + margin.left + margin.right)
           .attr("height", h + margin.top + margin.bottom)
           .append("g")
           .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
}

function truncate(str, maxLength, suffix) {
  if (str.length > maxLength) {
    str = str.substring(0, maxLength + 1); 
    str = str.substring(0, Math.min(str.length, str.lastIndexOf(" ")));
    str = str + suffix;
  }
  return str;
}

</script>